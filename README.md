# EEPROM SPI STM32 Library

**Zorunlu lise stajÄ±nda yazdÄ±ÄŸÄ±m eeprom spi kÃ¼tÃ¼phanesi**

A comprehensive SPI EEPROM library for STM32 microcontrollers written in 100% C. This library was developed during a mandatory high school internship and provides easy-to-use functions for interfacing with SPI-based EEPROM memory chips.

## ðŸ“‹ Table of Contents

- [Features](#features)
- [About SPI EEPROM Communication](#about-spi-eeprom-communication)
- [Supported EEPROM Chips](#supported-eeprom-chips)
- [Hardware Requirements](#hardware-requirements)
- [Wiring Diagram](#wiring-diagram)
- [Installation](#installation)
- [API Reference](#api-reference)
- [Usage Examples](#usage-examples)
- [Read/Write Operations](#readwrite-operations)
- [License](#license)
- [About the Project](#about-the-project)

## âœ¨ Features

- ðŸš€ Written in 100% C for maximum portability
- ðŸ“ Simple read and write operations
- ðŸ”„ Page write support for faster data transfer
- ðŸ›¡ï¸ Built-in error handling
- ðŸ“Š Support for multiple EEPROM sizes
- âš¡ Optimized for STM32 HAL library
- ðŸ“– Well-documented API

## ðŸ“¡ About SPI EEPROM Communication

SPI (Serial Peripheral Interface) is a synchronous serial communication protocol that uses four main lines:

- **MOSI** (Master Out Slave In): Data transmission from master to slave
- **MISO** (Master In Slave Out): Data transmission from slave to master
- **SCK** (Serial Clock): Clock signal generated by master
- **CS** (Chip Select): Slave selection signal

EEPROM chips communicate via SPI using specific command codes:
- **WRITE** (0x02): Write data to memory
- **READ** (0x03): Read data from memory
- **WREN** (0x06): Write Enable
- **WRDI** (0x04): Write Disable
- **RDSR** (0x05): Read Status Register
- **WRSR** (0x01): Write Status Register

The typical communication sequence:
1. Pull CS low to select the EEPROM
2. Send command byte
3. Send address bytes (typically 2 bytes for most EEPROMs)
4. Send/receive data
5. Pull CS high to deselect

## ðŸ”Œ Supported EEPROM Chips

This library supports various SPI EEPROM chips, including:

| Chip Model | Capacity | Page Size | Organization |
|------------|----------|-----------|--------------|
| 25LC010 | 1 Kbit | 16 bytes | 128 x 8 |
| 25LC020 | 2 Kbit | 16 bytes | 256 x 8 |
| 25LC040 | 4 Kbit | 16 bytes | 512 x 8 |
| 25LC080 | 8 Kbit | 16 bytes | 1024 x 8 |
| 25LC160 | 16 Kbit | 16 bytes | 2048 x 8 |
| 25LC320 | 32 Kbit | 32 bytes | 4096 x 8 |
| 25LC640 | 64 Kbit | 32 bytes | 8192 x 8 |
| 25LC1024 | 1 Mbit | 256 bytes | 131072 x 8 |

And compatible chips from other manufacturers (AT25xxx, CAT25xxx, etc.)

## ðŸ”§ Hardware Requirements

- STM32 microcontroller (any series with SPI peripheral)
- SPI EEPROM chip (e.g., 25LC series)
- 4.7kÎ© - 10kÎ© pull-up resistors (optional, for CS line)
- Breadboard and jumper wires for prototyping
- Power supply (3.3V or 5V depending on EEPROM chip)

## ðŸ”Œ Wiring Diagram

```
STM32                    25LC EEPROM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[SPI_SCK]  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> [SCK/Pin 6]
[SPI_MISO] <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ [SO/Pin 2]
[SPI_MOSI] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> [SI/Pin 5]
[GPIO_CS]  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> [CS/Pin 1]

[VCC]      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> [VCC/Pin 8]
[GND]      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> [VSS/Pin 4]
                             [HOLD/Pin 7] â”€â”€â”€ VCC
                             [WP/Pin 3]   â”€â”€â”€ VCC
```

### Pin Connections Details:

| STM32 Pin | EEPROM Pin | Function |
|-----------|------------|----------|
| SPI_SCK | Pin 6 (SCK) | Clock signal |
| SPI_MISO | Pin 2 (SO) | Data output from EEPROM |
| SPI_MOSI | Pin 5 (SI) | Data input to EEPROM |
| GPIO (CS) | Pin 1 (CS) | Chip select (active low) |
| VCC | Pin 8 (VCC) | Power supply |
| GND | Pin 4 (VSS) | Ground |
| VCC | Pin 7 (HOLD) | Hold function (pull high to disable) |
| VCC | Pin 3 (WP) | Write protect (pull high to disable) |

**Note:** HOLD and WP pins should be connected to VCC if not used to ensure normal operation.

## ðŸ“¥ Installation

1. Clone this repository:
```bash
git clone https://github.com/TroubledKezoo1/EEPPROM_SPI_STM32_LIBRARY.git
```

2. Copy the library files to your STM32 project:
   - Copy `.c` files to your `Src` folder
   - Copy `.h` files to your `Inc` folder

3. Include the header file in your main program:
```c
#include "eeprom_spi.h"
```

4. Configure SPI peripheral in STM32CubeMX:
   - Enable SPI (SPI1, SPI2, or SPI3)
   - Set mode to "Full-Duplex Master"
   - Configure clock prescaler based on your needs
   - Enable GPIO for CS pin

## ðŸ“š API Reference

### Initialization

```c
void EEPROM_SPI_Init(SPI_HandleTypeDef *hspi, GPIO_TypeDef *CS_Port, uint16_t CS_Pin);
```
Initialize the EEPROM library with SPI handle and CS pin configuration.

**Parameters:**
- `hspi`: Pointer to SPI handle
- `CS_Port`: GPIO port for chip select pin
- `CS_Pin`: GPIO pin number for chip select

---

### Write Operations

```c
HAL_StatusTypeDef EEPROM_SPI_WriteByte(uint16_t address, uint8_t data);
```
Write a single byte to EEPROM.

**Parameters:**
- `address`: Memory address (0 to EEPROM_SIZE-1)
- `data`: Byte to write

**Returns:** `HAL_OK` on success, `HAL_ERROR` on failure

---

```c
HAL_StatusTypeDef EEPROM_SPI_WriteBuffer(uint16_t address, uint8_t *data, uint16_t length);
```
Write multiple bytes to EEPROM.

**Parameters:**
- `address`: Starting memory address
- `data`: Pointer to data buffer
- `length`: Number of bytes to write

**Returns:** `HAL_OK` on success, `HAL_ERROR` on failure

---

```c
HAL_StatusTypeDef EEPROM_SPI_WritePage(uint16_t address, uint8_t *data, uint16_t length);
```
Write data using page write mode (faster for multiple bytes).

---

### Read Operations

```c
HAL_StatusTypeDef EEPROM_SPI_ReadByte(uint16_t address, uint8_t *data);
```
Read a single byte from EEPROM.

**Parameters:**
- `address`: Memory address to read from
- `data`: Pointer to store read byte

**Returns:** `HAL_OK` on success, `HAL_ERROR` on failure

---

```c
HAL_StatusTypeDef EEPROM_SPI_ReadBuffer(uint16_t address, uint8_t *data, uint16_t length);
```
Read multiple bytes from EEPROM.

**Parameters:**
- `address`: Starting memory address
- `data`: Pointer to buffer for storing read data
- `length`: Number of bytes to read

**Returns:** `HAL_OK` on success, `HAL_ERROR` on failure

---

### Status Operations

```c
uint8_t EEPROM_SPI_ReadStatus(void);
```
Read the status register of EEPROM.

**Returns:** Status register value

---

```c
uint8_t EEPROM_SPI_IsReady(void);
```
Check if EEPROM is ready for operation.

**Returns:** 1 if ready, 0 if busy

---

### Utility Functions

```c
void EEPROM_SPI_WriteEnable(void);
void EEPROM_SPI_WriteDisable(void);
HAL_StatusTypeDef EEPROM_SPI_EraseChip(void);
```

## ðŸ’¡ Usage Examples

### Basic Example

```c
#include "main.h"
#include "eeprom_spi.h"

SPI_HandleTypeDef hspi1;

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_SPI1_Init();
    MX_GPIO_Init();
    
    // Initialize EEPROM library
    EEPROM_SPI_Init(&hspi1, GPIOA, GPIO_PIN_4);
    
    // Write a single byte
    uint8_t write_data = 0xAA;
    EEPROM_SPI_WriteByte(0x0000, write_data);
    
    // Read back the byte
    uint8_t read_data;
    EEPROM_SPI_ReadByte(0x0000, &read_data);
    
    // Verify
    if(read_data == write_data) {
        // Success!
    }
    
    while(1)
    {
        // Main loop
    }
}
```

### Writing Multiple Bytes

```c
// Write a string to EEPROM
char message[] = "Hello, STM32!";
EEPROM_SPI_WriteBuffer(0x0010, (uint8_t*)message, strlen(message));

// Read back the string
char read_buffer[20] = {0};
EEPROM_SPI_ReadBuffer(0x0010, (uint8_t*)read_buffer, strlen(message));
```

### Page Write Example

```c
// Prepare data array
uint8_t data_array[32];
for(int i = 0; i < 32; i++) {
    data_array[i] = i;
}

// Write entire page
EEPROM_SPI_WritePage(0x0000, data_array, 32);

// Wait for write completion
while(!EEPROM_SPI_IsReady()) {
    HAL_Delay(1);
}
```

## ðŸ“– Read/Write Operations

### Write Cycle Timing

- **Write Cycle Time**: Typically 5ms (max)
- **Page Write Time**: Same as byte write (5ms max)
- Always check `EEPROM_SPI_IsReady()` before next operation

### Page Write Considerations

1. **Page Alignment**: Data written must not cross page boundaries
2. **Page Size**: Varies by EEPROM model (16, 32, or 256 bytes)
3. **Wrap-Around**: Writing beyond page boundary wraps to page start

Example of page boundary:
```
Address 0x00 - 0x0F: Page 0 (16-byte page)
Address 0x10 - 0x1F: Page 1
Address 0x20 - 0x2F: Page 2
```

### Best Practices

âœ… **DO:**
- Always wait for write completion before next operation
- Use page writes for multiple consecutive bytes
- Check return values for error handling
- Add appropriate delays after write operations

âŒ **DON'T:**
- Write across page boundaries in single page write
- Perform operations while EEPROM is busy
- Exceed maximum write endurance (typically 1M cycles)
- Write without enabling write mode first

## ðŸ“„ License

This project is open source and available under the MIT License.

## ðŸ‘¨â€ðŸ’» About the Project

This library was developed during my **mandatory high school internship** (zorunlu lise stajÄ±) as a practical project to learn embedded systems programming and hardware interfacing.

### Development Background

- **Language**: 100% C
- **Platform**: STM32 microcontrollers
- **Development Environment**: STM32CubeIDE
- **Purpose**: Educational project for high school internship
- **Year**: 2026

### Learning Outcomes

Through this project, I gained experience in:
- SPI communication protocol
- EEPROM memory architecture
- Embedded C programming
- STM32 HAL library usage
- Hardware interfacing and debugging
- Documentation and code organization

### Future Improvements

Potential enhancements for this library:
- [ ] Add support for different memory sizes auto-detection
- [ ] Implement DMA support for faster transfers
- [ ] Add CRC checksum for data integrity
- [ ] Create examples for different STM32 series
- [ ] Add power-down mode support
- [ ] Implement wear leveling algorithms

---

## ðŸ¤ Contributing

Contributions, issues, and feature requests are welcome! Feel free to check the [issues page](https://github.com/TroubledKezoo1/EEPPROM_SPI_STM32_LIBRARY/issues).

## ðŸ“§ Contact

**TroubledKezoo1** - [@TroubledKezoo1](https://github.com/TroubledKezoo1)

Project Link: [https://github.com/TroubledKezoo1/EEPPROM_SPI_STM32_LIBRARY](https://github.com/TroubledKezoo1/EEPPROM_SPI_STM32_LIBRARY)

---

â­ If you find this library helpful, please consider giving it a star!

**Made with â¤ï¸ during high school internship**
